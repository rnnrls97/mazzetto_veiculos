import {
  OptionTypes,
  create$f,
  registerPlugin,
  supported
} from "./chunk-UDNBXEAK.js";
import "./chunk-VTJ5T7PO.js";
import {
  h
} from "./chunk-QKC65U2J.js";
import "./chunk-LK32TJAX.js";

// node_modules/vue-filepond/dist/vue-filepond.esm.js
var filteredComponentMethods = [
  "setOptions",
  "on",
  "off",
  "onOnce",
  "appendTo",
  "insertAfter",
  "insertBefore",
  "isAttachedTo",
  "replaceElement",
  "restoreElement",
  "destroy"
];
var isSupported = supported();
var getNativeConstructorFromType = (type) => ({
  string: String,
  boolean: Boolean,
  array: Array,
  function: Function,
  int: Number,
  serverapi: Object,
  object: Object
})[type];
var props = {};
var events = [];
var instances = [];
var globalOptions = {};
var setOptions = (options) => {
  globalOptions = Object.assign(globalOptions, options);
  instances.forEach((instance) => {
    instance.setOptions(globalOptions);
  });
};
var vue_filepond_esm_default = (...plugins) => {
  registerPlugin(...plugins);
  events.length = 0;
  for (const prop in OptionTypes) {
    if (/^on/.test(prop)) {
      events.push(prop);
      continue;
    }
    let valid_types = [String, getNativeConstructorFromType(OptionTypes[prop])];
    if (prop == "labelFileProcessingError") {
      valid_types.push(Function);
    }
    props[prop] = {
      type: valid_types,
      // set this default value so we know which props have been explicitely set by user on component
      default: void 0
    };
  }
  return {
    name: "FilePond",
    props,
    render() {
      const attributes = Object.entries({
        id: this.id,
        name: this.name,
        type: "file",
        class: this.className,
        required: this.required,
        multiple: this.allowMultiple,
        accept: this.acceptedFileTypes,
        capture: this.captureMethod
      }).reduce((attributes2, [key, value]) => {
        if (value !== void 0) attributes2[key] = value;
        return attributes2;
      }, {});
      return h(
        "div",
        {
          class: {
            "filepond--wrapper": true
          }
        },
        [h("input", attributes)]
      );
    },
    created() {
      this.watchers = Object.keys(props).map((key) => {
        return this.$watch(key, (next) => {
          if (!this._pond) return;
          this._pond[key] = next;
        });
      });
    },
    // Will setup FilePond instance when mounted
    mounted() {
      if (!isSupported) return;
      this._element = this.$el.querySelector("input");
      const options = events.reduce((obj, value) => {
        obj[value] = (...args) => {
          this.$emit("input", this._pond ? this._pond.getFiles() : []);
          this.$emit(value.substr(2), ...args);
        };
        return obj;
      }, {});
      const passedProps = {};
      Object.keys(props).forEach((key) => {
        if (this[key] === void 0) return;
        passedProps[key] = this[key];
      });
      this._pond = create$f(
        this._element,
        Object.assign({}, globalOptions, options, passedProps)
      );
      Object.keys(this._pond).filter((key) => !filteredComponentMethods.includes(key)).forEach((key) => {
        this[key] = this._pond[key];
      });
      instances.push(this._pond);
    },
    // Will clean up FilePond instance when unmounted
    beforeUnmount() {
      const { detached } = this.$options;
      if (!this.$el.offsetParent) {
        detached.call(this);
        return;
      }
      const mutationHandler = (mutations, observer2) => {
        const removedNodes = (mutations[0] || {}).removedNodes || [];
        const removedNode = removedNodes[0];
        if (!removedNode || !removedNode.contains(this.$el)) return;
        observer2.disconnect();
        detached.call(this);
      };
      const observer = new MutationObserver(mutationHandler);
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true
      });
    },
    // called when the component root node has been detached
    detached() {
      this.watchers.forEach((unwatch) => unwatch());
      if (!this._pond) return;
      this._pond.destroy();
      const index = instances.indexOf(this._pond);
      if (index >= 0) {
        instances.splice(index, 1);
      }
      this._pond = null;
    }
  };
};
export {
  vue_filepond_esm_default as default,
  setOptions
};
/*! Bundled license information:

vue-filepond/dist/vue-filepond.esm.js:
  (*!
   * vue-filepond v7.0.4
   * A handy FilePond adapter component for Vue
   * 
   * Copyright (c) 2023 PQINA
   * https://pqina.nl/filepond
   * 
   * Licensed under the MIT license.
   *)
*/
//# sourceMappingURL=vue-filepond.js.map
