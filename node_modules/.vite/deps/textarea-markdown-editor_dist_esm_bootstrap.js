import {
  __commonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/mousetrap/mousetrap.js
var require_mousetrap = __commonJS({
  "node_modules/mousetrap/mousetrap.js"(exports, module) {
    (function(window2, document2, undefined2) {
      if (!window2) {
        return;
      }
      var _MAP = {
        8: "backspace",
        9: "tab",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "ins",
        46: "del",
        91: "meta",
        93: "meta",
        224: "meta"
      };
      var _KEYCODE_MAP = {
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      var _SHIFT_MAP = {
        "~": "`",
        "!": "1",
        "@": "2",
        "#": "3",
        "$": "4",
        "%": "5",
        "^": "6",
        "&": "7",
        "*": "8",
        "(": "9",
        ")": "0",
        "_": "-",
        "+": "=",
        ":": ";",
        '"': "'",
        "<": ",",
        ">": ".",
        "?": "/",
        "|": "\\"
      };
      var _SPECIAL_ALIASES = {
        "option": "alt",
        "command": "meta",
        "return": "enter",
        "escape": "esc",
        "plus": "+",
        "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
      };
      var _REVERSE_MAP;
      for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = "f" + i;
      }
      for (i = 0; i <= 9; ++i) {
        _MAP[i + 96] = i.toString();
      }
      function _addEvent(object, type, callback) {
        if (object.addEventListener) {
          object.addEventListener(type, callback, false);
          return;
        }
        object.attachEvent("on" + type, callback);
      }
      function _characterFromEvent(e) {
        if (e.type == "keypress") {
          var character = String.fromCharCode(e.which);
          if (!e.shiftKey) {
            character = character.toLowerCase();
          }
          return character;
        }
        if (_MAP[e.which]) {
          return _MAP[e.which];
        }
        if (_KEYCODE_MAP[e.which]) {
          return _KEYCODE_MAP[e.which];
        }
        return String.fromCharCode(e.which).toLowerCase();
      }
      function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(",") === modifiers2.sort().join(",");
      }
      function _eventModifiers(e) {
        var modifiers = [];
        if (e.shiftKey) {
          modifiers.push("shift");
        }
        if (e.altKey) {
          modifiers.push("alt");
        }
        if (e.ctrlKey) {
          modifiers.push("ctrl");
        }
        if (e.metaKey) {
          modifiers.push("meta");
        }
        return modifiers;
      }
      function _preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
          return;
        }
        e.returnValue = false;
      }
      function _stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
          return;
        }
        e.cancelBubble = true;
      }
      function _isModifier(key) {
        return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
      }
      function _getReverseMap() {
        if (!_REVERSE_MAP) {
          _REVERSE_MAP = {};
          for (var key in _MAP) {
            if (key > 95 && key < 112) {
              continue;
            }
            if (_MAP.hasOwnProperty(key)) {
              _REVERSE_MAP[_MAP[key]] = key;
            }
          }
        }
        return _REVERSE_MAP;
      }
      function _pickBestAction(key, modifiers, action) {
        if (!action) {
          action = _getReverseMap()[key] ? "keydown" : "keypress";
        }
        if (action == "keypress" && modifiers.length) {
          action = "keydown";
        }
        return action;
      }
      function _keysFromString(combination) {
        if (combination === "+") {
          return ["+"];
        }
        combination = combination.replace(/\+{2}/g, "+plus");
        return combination.split("+");
      }
      function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i2;
        var modifiers = [];
        keys = _keysFromString(combination);
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (_SPECIAL_ALIASES[key]) {
            key = _SPECIAL_ALIASES[key];
          }
          if (action && action != "keypress" && _SHIFT_MAP[key]) {
            key = _SHIFT_MAP[key];
            modifiers.push("shift");
          }
          if (_isModifier(key)) {
            modifiers.push(key);
          }
        }
        action = _pickBestAction(key, modifiers, action);
        return {
          key,
          modifiers,
          action
        };
      }
      function _belongsTo(element, ancestor) {
        if (element === null || element === document2) {
          return false;
        }
        if (element === ancestor) {
          return true;
        }
        return _belongsTo(element.parentNode, ancestor);
      }
      function Mousetrap3(targetElement) {
        var self = this;
        targetElement = targetElement || document2;
        if (!(self instanceof Mousetrap3)) {
          return new Mousetrap3(targetElement);
        }
        self.target = targetElement;
        self._callbacks = {};
        self._directMap = {};
        var _sequenceLevels = {};
        var _resetTimer;
        var _ignoreNextKeyup = false;
        var _ignoreNextKeypress = false;
        var _nextExpectedAction = false;
        function _resetSequences(doNotReset) {
          doNotReset = doNotReset || {};
          var activeSequences = false, key;
          for (key in _sequenceLevels) {
            if (doNotReset[key]) {
              activeSequences = true;
              continue;
            }
            _sequenceLevels[key] = 0;
          }
          if (!activeSequences) {
            _nextExpectedAction = false;
          }
        }
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
          var i2;
          var callback;
          var matches = [];
          var action = e.type;
          if (!self._callbacks[character]) {
            return [];
          }
          if (action == "keyup" && _isModifier(character)) {
            modifiers = [character];
          }
          for (i2 = 0; i2 < self._callbacks[character].length; ++i2) {
            callback = self._callbacks[character][i2];
            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
              continue;
            }
            if (action != callback.action) {
              continue;
            }
            if (action == "keypress" && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
              var deleteCombo = !sequenceName && callback.combo == combination;
              var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
              if (deleteCombo || deleteSequence) {
                self._callbacks[character].splice(i2, 1);
              }
              matches.push(callback);
            }
          }
          return matches;
        }
        function _fireCallback(callback, e, combo, sequence) {
          if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
            return;
          }
          if (callback(e, combo) === false) {
            _preventDefault(e);
            _stopPropagation(e);
          }
        }
        self._handleKey = function(character, modifiers, e) {
          var callbacks = _getMatches(character, modifiers, e);
          var i2;
          var doNotReset = {};
          var maxLevel = 0;
          var processedSequenceCallback = false;
          for (i2 = 0; i2 < callbacks.length; ++i2) {
            if (callbacks[i2].seq) {
              maxLevel = Math.max(maxLevel, callbacks[i2].level);
            }
          }
          for (i2 = 0; i2 < callbacks.length; ++i2) {
            if (callbacks[i2].seq) {
              if (callbacks[i2].level != maxLevel) {
                continue;
              }
              processedSequenceCallback = true;
              doNotReset[callbacks[i2].seq] = 1;
              _fireCallback(callbacks[i2].callback, e, callbacks[i2].combo, callbacks[i2].seq);
              continue;
            }
            if (!processedSequenceCallback) {
              _fireCallback(callbacks[i2].callback, e, callbacks[i2].combo);
            }
          }
          var ignoreThisKeypress = e.type == "keypress" && _ignoreNextKeypress;
          if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
            _resetSequences(doNotReset);
          }
          _ignoreNextKeypress = processedSequenceCallback && e.type == "keydown";
        };
        function _handleKeyEvent(e) {
          if (typeof e.which !== "number") {
            e.which = e.keyCode;
          }
          var character = _characterFromEvent(e);
          if (!character) {
            return;
          }
          if (e.type == "keyup" && _ignoreNextKeyup === character) {
            _ignoreNextKeyup = false;
            return;
          }
          self.handleKey(character, _eventModifiers(e), e);
        }
        function _resetSequenceTimer() {
          clearTimeout(_resetTimer);
          _resetTimer = setTimeout(_resetSequences, 1e3);
        }
        function _bindSequence(combo, keys, callback, action) {
          _sequenceLevels[combo] = 0;
          function _increaseSequence(nextAction) {
            return function() {
              _nextExpectedAction = nextAction;
              ++_sequenceLevels[combo];
              _resetSequenceTimer();
            };
          }
          function _callbackAndReset(e) {
            _fireCallback(callback, e, combo);
            if (action !== "keyup") {
              _ignoreNextKeyup = _characterFromEvent(e);
            }
            setTimeout(_resetSequences, 10);
          }
          for (var i2 = 0; i2 < keys.length; ++i2) {
            var isFinal = i2 + 1 === keys.length;
            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i2 + 1]).action);
            _bindSingle(keys[i2], wrappedCallback, action, combo, i2);
          }
        }
        function _bindSingle(combination, callback, action, sequenceName, level) {
          self._directMap[combination + ":" + action] = callback;
          combination = combination.replace(/\s+/g, " ");
          var sequence = combination.split(" ");
          var info;
          if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action);
            return;
          }
          info = _getKeyInfo(combination, action);
          self._callbacks[info.key] = self._callbacks[info.key] || [];
          _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
          self._callbacks[info.key][sequenceName ? "unshift" : "push"]({
            callback,
            modifiers: info.modifiers,
            action: info.action,
            seq: sequenceName,
            level,
            combo: combination
          });
        }
        self._bindMultiple = function(combinations, callback, action) {
          for (var i2 = 0; i2 < combinations.length; ++i2) {
            _bindSingle(combinations[i2], callback, action);
          }
        };
        _addEvent(targetElement, "keypress", _handleKeyEvent);
        _addEvent(targetElement, "keydown", _handleKeyEvent);
        _addEvent(targetElement, "keyup", _handleKeyEvent);
      }
      Mousetrap3.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
      };
      Mousetrap3.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {
        }, action);
      };
      Mousetrap3.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ":" + action]) {
          self._directMap[keys + ":" + action]({}, keys);
        }
        return self;
      };
      Mousetrap3.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
      };
      Mousetrap3.prototype.stopCallback = function(e, element) {
        var self = this;
        if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
          return false;
        }
        if (_belongsTo(element, self.target)) {
          return false;
        }
        if ("composedPath" in e && typeof e.composedPath === "function") {
          var initialEventTarget = e.composedPath()[0];
          if (initialEventTarget !== e.target) {
            element = initialEventTarget;
          }
        }
        return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
      };
      Mousetrap3.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
      };
      Mousetrap3.addKeycodes = function(object) {
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            _MAP[key] = object[key];
          }
        }
        _REVERSE_MAP = null;
      };
      Mousetrap3.init = function() {
        var documentMousetrap = Mousetrap3(document2);
        for (var method in documentMousetrap) {
          if (method.charAt(0) !== "_") {
            Mousetrap3[method] = /* @__PURE__ */ function(method2) {
              return function() {
                return documentMousetrap[method2].apply(documentMousetrap, arguments);
              };
            }(method);
          }
        }
      };
      Mousetrap3.init();
      window2.Mousetrap = Mousetrap3;
      if (typeof module !== "undefined" && module.exports) {
        module.exports = Mousetrap3;
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Mousetrap3;
        });
      }
    })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
  }
});

// node_modules/textarea-markdown-editor/dist/esm/bootstrap.js
var import_mousetrap2 = __toESM(require_mousetrap());

// node_modules/textarea-markdown-editor/dist/esm/utils.js
var metaCombination = function() {
  var keys = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    keys[_i] = arguments[_i];
  }
  return ["command+".concat(keys.join("+")), "ctrl+".concat(keys.join("+"))];
};
var clamp = function(val, min, max) {
  return Math.min(Math.max(min, val), max);
};
var findLast = function(array, predicate) {
  var curIndex = array.length;
  while (curIndex--) {
    if (predicate(array[curIndex], curIndex, array))
      return array[curIndex];
  }
  return void 0;
};
var trimChars = function(text, chars) {
  return text.replace(new RegExp("^[" + escapeRegExp(chars) + "]+|[" + chars + "]+$", "g"), "");
};
var isBtwOrEq = function(value, a, b) {
  return value >= Math.min(a, b) && value <= Math.max(a, b);
};
var browserSupportsTextareaTextNodes;
function canManipulateViaTextNodes(input) {
  if (input.nodeName !== "TEXTAREA") {
    return false;
  }
  if (typeof browserSupportsTextareaTextNodes === "undefined") {
    var textarea = document.createElement("textarea");
    textarea.value = "1";
    browserSupportsTextareaTextNodes = Boolean(textarea.firstChild);
  }
  return browserSupportsTextareaTextNodes;
}
function fireInput(input, value) {
  input.focus();
  input.select();
  var isSuccess = document.execCommand && document.execCommand("insertText", false, value);
  input.selectionStart = input.value.length;
  if (!isSuccess) {
    var start = input.selectionStart;
    var end = input.selectionEnd;
    if (typeof input.setRangeText === "function") {
      input.setRangeText(value);
    } else {
      var range = document.createRange();
      var textNode = document.createTextNode(value);
      if (canManipulateViaTextNodes(input)) {
        var node = input.firstChild;
        if (!node) {
          input.appendChild(textNode);
        } else {
          var offset = 0;
          var startNode = null;
          var endNode = null;
          while (node && (startNode === null || endNode === null)) {
            var nodeLength = node.nodeValue.length;
            if (start >= offset && start <= offset + nodeLength) {
              range.setStart(startNode = node, start - offset);
            }
            if (end >= offset && end <= offset + nodeLength) {
              range.setEnd(endNode = node, end - offset);
            }
            offset += nodeLength;
            node = node.nextSibling;
          }
          if (start !== end) {
            range.deleteContents();
          }
        }
      }
      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === "#text") {
        range.insertNode(textNode);
      } else {
        input.value = value;
      }
    }
    var e = document.createEvent("UIEvent");
    e.initEvent("input", true, false);
    input.dispatchEvent(e);
  }
}
var getIncrementedOrderedListPrefix = function(prefix) {
  var parts = trimChars(prefix.trim(), ".").split(".");
  var currentCount = parseInt(parts[parts.length - 1]);
  if (parts.length === 1) {
    return "".concat(currentCount + 1, ".");
  }
  return "".concat(parts.slice(0, -1).join("."), ".").concat(currentCount + 1, ".");
};
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var isURL = function(value) {
  try {
    return typeof value === "string" && Boolean(new URL(value));
  } catch (error) {
    return false;
  }
};
var isImageURL = function(value) {
  return isURL(value) && value.match(/\.(jpeg|jpg|gif|png)$/) !== null;
};
var HistoryStack = (
  /** @class */
  function() {
    function HistoryStack2(limit) {
      this.limit = limit;
      this.items = [];
    }
    HistoryStack2.prototype.push = function(item) {
      this.items.push(item);
      if (this.items.length >= this.limit) {
        this.items.splice(0, 1);
      }
    };
    HistoryStack2.prototype.peek = function(n) {
      return this.items[this.items.length - n];
    };
    HistoryStack2.prototype.pop = function() {
      return this.items.pop();
    };
    return HistoryStack2;
  }()
);

// node_modules/textarea-markdown-editor/dist/esm/Cursor.new.js
var MARKER = "\0";
var Cursor = (
  /** @class */
  function() {
    function Cursor2(element) {
      this.element = element;
      this.MARKER = MARKER;
    }
    Object.defineProperty(Cursor2.prototype, "value", {
      get: function() {
        return this.element.value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Cursor2.prototype, "lines", {
      /** @returns {Line[]} information about each line of text */
      get: function() {
        var currentLength = 0;
        return this.value.split("\n").reduce(function(lines, content, index, arr) {
          var lineNumber = index + 1;
          var isLastLine = index === arr.length - 1;
          var lineLength = content.length + Number(!isLastLine);
          var startsAt = currentLength;
          var endsAt = startsAt + lineLength - Number(!isLastLine);
          currentLength += lineLength;
          lines.push({
            text: content,
            lineNumber,
            startsAt,
            endsAt
          });
          return lines;
        }, []);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Cursor2.prototype, "selection", {
      /** @returns {Selection} information about current selection */
      get: function() {
        var selectionStart = this.element.selectionStart;
        var selectionEnd = this.element.selectionEnd;
        var selectionDirection = this.element.selectionDirection;
        var text = this.value.slice(selectionStart, selectionEnd);
        var lines = this.lines.filter(function(line) {
          return isBtwOrEq(selectionStart, line.startsAt, line.endsAt) || // selection ends inside a line
          isBtwOrEq(selectionEnd, line.startsAt, line.endsAt) || // line inside selection from left
          isBtwOrEq(line.startsAt, selectionStart, selectionEnd) || // line inside selection from right
          isBtwOrEq(line.endsAt, selectionStart, selectionEnd);
        });
        if (selectionStart === selectionEnd) {
          return null;
        }
        return { lines, selectionStart, selectionEnd, selectionDirection, text };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Cursor2.prototype, "position", {
      /** @returns {Position} information about current position */
      get: function() {
        var position = this.element.selectionStart;
        var line = this.lines.find(function(line2) {
          return position >= line2.startsAt && position <= line2.endsAt;
        });
        return { cursorAt: position, line };
      },
      enumerable: false,
      configurable: true
    });
    Cursor2.prototype.setValue = function(text) {
      var data = this.execRaw(text);
      if (false) {
        this.element.value = data.text;
      } else {
        fireInput(this.element, data.text);
      }
      if (data.selectionStart === null && data.selectionEnd === null) {
        return;
      }
      if (data.selectionStart !== null && (data.selectionEnd === null || data.selectionStart === data.selectionEnd)) {
        this.element.selectionStart = data.selectionStart;
        this.element.selectionEnd = data.selectionStart;
      } else {
        this.element.setSelectionRange(data.selectionStart, data.selectionEnd);
      }
    };
    Cursor2.prototype.lineAt = function(lineNumber) {
      var _a;
      return (_a = this.lines[lineNumber - 1]) !== null && _a !== void 0 ? _a : null;
    };
    Cursor2.prototype.insert = function(content) {
      if (!this.selection) {
        this.insertAtCursor(content);
        return;
      }
      var start = this.selection.selectionStart;
      var end = this.selection.selectionEnd;
      var newValue = this.value.slice(0, start) + this.normalizeSelection(content) + this.value.slice(end);
      this.setValue(newValue);
    };
    Cursor2.prototype.insertAtCursor = function(content) {
      var cursorAt = this.position.cursorAt;
      var newValue = this.value.slice(0, cursorAt) + this.normalizeSelection(content) + this.value.slice(cursorAt, this.value.length);
      this.setValue(newValue);
    };
    Cursor2.prototype.replaceCurrentLines = function(callback, options) {
      var _this = this;
      var _a, _b;
      var _c = (options !== null && options !== void 0 ? options : {}).selectReplaced, selectReplaced = _c === void 0 ? false : _c;
      var selectedLines = (_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.lines) !== null && _b !== void 0 ? _b : [this.lineAt(this.position.line.lineNumber)];
      var content = selectedLines.map(function(line, index) {
        return callback.call(_this, line, index, selectedLines);
      }).filter(function(ctn) {
        return ctn !== null;
      }).join("\n");
      var start = selectedLines[0].startsAt;
      var end = selectedLines[selectedLines.length - 1].endsAt;
      var newValue = this.value.slice(0, start) + this.normalizeSelection(content, selectReplaced ? "SELECT_ALL" : "TO_END") + this.value.slice(end);
      this.setValue(newValue);
    };
    Cursor2.prototype.replaceLine = function(lineNumber, content) {
      var line = this.lineAt(lineNumber);
      if (!line) {
        console.error("Unknown line number: " + lineNumber);
        return;
      }
      var start = line.startsAt;
      var end = line.endsAt;
      if (content === null) {
        this.setValue(this.value.slice(0, start - 1) + MARKER + this.value.slice(end));
        return;
      }
      var newValue = this.value.slice(0, start) + this.normalizeSelection(content) + this.value.slice(end);
      this.setValue(newValue);
    };
    Cursor2.prototype.wrap = function(markup, options) {
      var _a, _b, _c, _d;
      var _e = options !== null && options !== void 0 ? options : {}, _f = _e.unwrap, unwrap = _f === void 0 ? true : _f, _g = _e.placeholder, placeholder = _g === void 0 ? "" : _g;
      var _h = Array.isArray(markup) ? markup : [markup, markup], prefix = _h[0], suffix = _h[1];
      var text = this.value;
      var start = (_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.selectionStart) !== null && _b !== void 0 ? _b : this.position.cursorAt;
      var end = (_d = (_c = this.selection) === null || _c === void 0 ? void 0 : _c.selectionEnd) !== null && _d !== void 0 ? _d : this.position.cursorAt;
      if (this.isSelectedWrappedWith(markup) && unwrap) {
        var content_1 = [
          text.slice(0, start - prefix.length),
          MARKER,
          text.slice(start, end),
          MARKER,
          text.slice(end + suffix.length)
        ].join("");
        this.setValue(content_1);
        return;
      }
      var content = [
        //
        text.slice(0, start),
        prefix,
        MARKER,
        text.slice(start, end) || placeholder,
        MARKER,
        suffix,
        text.slice(end)
      ].join("");
      this.setValue(content);
    };
    Cursor2.prototype.isSelectedWrappedWith = function(markup) {
      var _a, _b, _c, _d;
      var _e = Array.isArray(markup) ? markup : [markup, markup], prefix = _e[0], suffix = _e[1];
      var start = (_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.selectionStart) !== null && _b !== void 0 ? _b : this.position.cursorAt;
      var end = (_d = (_c = this.selection) === null || _c === void 0 ? void 0 : _c.selectionEnd) !== null && _d !== void 0 ? _d : this.position.cursorAt;
      if (start - prefix.length < 0 || end - 1 + suffix.length > this.value.length - 1) {
        return false;
      }
      var curPrefix = this.value.slice(start - prefix.length, start);
      var curSuffix = this.value.slice(end, end + suffix.length);
      return curPrefix === prefix && curSuffix === suffix;
    };
    Cursor2.prototype.select = function(options) {
      var isRange = function(opt) {
        return Object.prototype.hasOwnProperty.call(opt, "start") && Object.prototype.hasOwnProperty.call(opt, "end");
      };
      if (isRange(options)) {
        this.element.setSelectionRange(options.start, options.end);
      } else {
        this.element.setSelectionRange(this.element.selectionStart + options.fromCurrentStart, this.element.selectionEnd + options.fromCurrentEnd);
      }
    };
    Cursor2.prototype.normalizeSelection = function(text, defaultBehavior) {
      if (defaultBehavior === void 0) {
        defaultBehavior = "TO_END";
      }
      if (text.includes(MARKER)) {
        return text;
      }
      switch (defaultBehavior) {
        case "TO_START":
          return "".concat(MARKER).concat(text);
        case "TO_END":
          return "".concat(text).concat(MARKER);
        case "SELECT_ALL":
          return "".concat(MARKER).concat(text).concat(MARKER);
      }
    };
    Cursor2.prototype.execRaw = function(text) {
      var fIndex = text.indexOf(MARKER);
      var lIndex = text.lastIndexOf(MARKER);
      if (fIndex !== -1 && lIndex !== -1) {
        text = text.replace(new RegExp(MARKER, "g"), "");
      }
      var selectionStart = null;
      var selectionEnd = null;
      if (fIndex !== -1) {
        selectionStart = fIndex;
        selectionEnd = lIndex === -1 || lIndex === fIndex ? null : lIndex - 1;
      }
      return { text, selectionStart, selectionEnd };
    };
    Cursor2.MARKER = MARKER;
    return Cursor2;
  }()
);

// node_modules/textarea-markdown-editor/dist/esm/handlers.js
var boldCommandHandler = function(_a) {
  var cursor = _a.cursor, _b = _a.options, preferredBoldSyntax = _b.preferredBoldSyntax, boldPlaceholder = _b.boldPlaceholder;
  cursor.wrap(preferredBoldSyntax, { placeholder: boldPlaceholder });
};
var italicCommandHandler = function(_a) {
  var cursor = _a.cursor, _b = _a.options, preferredItalicSyntax = _b.preferredItalicSyntax, italicPlaceholder = _b.italicPlaceholder;
  cursor.wrap(preferredItalicSyntax, { placeholder: italicPlaceholder });
};
var linkCommandHandler = function(_a) {
  var _b;
  var options = _a.options, cursor = _a.cursor;
  var linkTextPlaceholder = options.linkTextPlaceholder, linkUrlPlaceholder = options.linkUrlPlaceholder;
  var linkText = ((_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.text) || linkTextPlaceholder;
  var linkUrl = linkUrlPlaceholder;
  cursor.insert("[".concat(linkText, "](").concat(Cursor.MARKER).concat(linkUrl).concat(Cursor.MARKER, ")"));
};
var imageCommandHandler = function(_a) {
  var _b;
  var options = _a.options, cursor = _a.cursor;
  var imageTextPlaceholder = options.imageTextPlaceholder, imageUrlPlaceholder = options.imageUrlPlaceholder;
  var imageText = ((_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.text) || imageTextPlaceholder;
  var imageUrl = imageUrlPlaceholder;
  cursor.insert("![".concat(imageText, "](").concat(Cursor.MARKER).concat(imageUrl).concat(Cursor.MARKER, ")"));
};
var orderedListCommandHandler = function(_a) {
  var _b, _c;
  var cursor = _a.cursor;
  var re = /(\d+\.){1,2}\s+/;
  var lines = (_c = (_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.lines) !== null && _c !== void 0 ? _c : [cursor.position.line];
  var needUndo = lines.every(function(line) {
    return re.test(line.text);
  });
  cursor.replaceCurrentLines(function(line, index) {
    return needUndo ? line.text.replace(re, "") : "".concat(index + 1, ". ").concat(line.text);
  }, {
    selectReplaced: Boolean(cursor.selection)
  });
};
var unorderedListCommandHandler = function(_a) {
  var _b, _c;
  var cursor = _a.cursor, options = _a.options;
  var syntax = options.preferredUnorderedListSyntax;
  var re = new RegExp("^".concat(escapeRegExp(syntax), "\\s+"));
  var lines = (_c = (_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.lines) !== null && _c !== void 0 ? _c : [cursor.position.line];
  var needUndo = lines.every(function(line) {
    return re.test(line.text);
  });
  cursor.replaceCurrentLines(function(line) {
    return needUndo ? line.text.replace(re, "") : "".concat(syntax, " ").concat(line.text);
  }, {
    selectReplaced: Boolean(cursor.selection)
  });
};
var codeBlockCommandHandler = function(_a) {
  var cursor = _a.cursor, codeBlockPlaceholder = _a.options.codeBlockPlaceholder;
  cursor.wrap(["```\n", "\n```"], { placeholder: codeBlockPlaceholder });
};
var codeInlineCommandHandler = function(_a) {
  var cursor = _a.cursor, codeInlinePlaceholder = _a.options.codeInlinePlaceholder;
  cursor.wrap("`", { placeholder: codeInlinePlaceholder });
};
var codeCommandHandler = function(ctx) {
  var _a, _b;
  var selectedLines = (_b = (_a = ctx.cursor.selection) === null || _a === void 0 ? void 0 : _a.lines) !== null && _b !== void 0 ? _b : [];
  if (selectedLines.length > 1) {
    codeBlockCommandHandler(ctx);
  } else {
    codeInlineCommandHandler(ctx);
  }
};
var blockQuotesCommandHandler = function(_a) {
  var cursor = _a.cursor, options = _a.options;
  cursor.replaceCurrentLines(function(line, index, lines) {
    return [
      index === 0 ? "> " : "",
      index === 0 ? Cursor.MARKER : "",
      line.text.replace(/^>\s+/, "") || (index === 0 ? options.blockQuotesPlaceholder : ""),
      index === lines.length - 1 ? Cursor.MARKER : ""
      // selection closing for the last line
    ].join("");
  });
};
var strikeThroughCommandHandler = function(_a) {
  var cursor = _a.cursor, strikeThroughPlaceholder = _a.options.strikeThroughPlaceholder;
  cursor.wrap("~~", { placeholder: strikeThroughPlaceholder });
};
var createHeadlineCommandHandler = function(level) {
  return function(_a) {
    var cursor = _a.cursor, options = _a.options;
    var prefix = "#".repeat(clamp(level, 1, 6)) + " ";
    var headlinePlaceholder = options.headlinePlaceholder;
    var placeholder = headlinePlaceholder instanceof Function ? headlinePlaceholder(level) : headlinePlaceholder;
    var currentLine = cursor.position.line;
    var needUndo = currentLine.text.slice(0, level + 1) === prefix;
    var content = currentLine.text.replace(/^#{0,6}\s+/, "") || placeholder;
    cursor.replaceLine(currentLine.lineNumber, "".concat(needUndo ? "" : prefix).concat(Cursor.MARKER).concat(content).concat(Cursor.MARKER));
  };
};

// node_modules/textarea-markdown-editor/dist/esm/commands.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var buildInCommands = [
  {
    shortcut: metaCombination("b"),
    handler: boldCommandHandler,
    name: "bold"
  },
  {
    shortcut: metaCombination("i"),
    handler: italicCommandHandler,
    name: "italic"
  },
  {
    name: "link",
    handler: linkCommandHandler
  },
  {
    name: "image",
    handler: imageCommandHandler
  },
  {
    name: "unordered-list",
    handler: unorderedListCommandHandler
  },
  {
    name: "ordered-list",
    handler: orderedListCommandHandler
  },
  {
    name: "code-block",
    handler: codeBlockCommandHandler
  },
  {
    name: "code-inline",
    handler: codeInlineCommandHandler
  },
  {
    name: "code",
    handler: codeCommandHandler
  },
  {
    name: "block-quotes",
    handler: blockQuotesCommandHandler
  },
  {
    shortcut: __spreadArray(__spreadArray([], metaCombination("shift", "x"), true), ["alt+shift+f5"], false),
    name: "strike-through",
    handler: strikeThroughCommandHandler
  },
  {
    name: "h1",
    handler: createHeadlineCommandHandler(1)
  },
  {
    name: "h2",
    handler: createHeadlineCommandHandler(2)
  },
  {
    name: "h3",
    handler: createHeadlineCommandHandler(3)
  },
  {
    name: "h4",
    handler: createHeadlineCommandHandler(4)
  },
  {
    name: "h5",
    handler: createHeadlineCommandHandler(5)
  },
  {
    name: "h6",
    handler: createHeadlineCommandHandler(6)
  }
];

// node_modules/textarea-markdown-editor/dist/esm/extensions.js
var import_mousetrap = __toESM(require_mousetrap());
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var linkPasteExtension = function(textarea) {
  var cursor = new Cursor(textarea);
  var pasteListener = function(event) {
    var _a;
    var LINK_MARKUP_RE = /\[[^\]]*\]\([^)]*\)/g;
    var clipboard = (_a = event === null || event === void 0 ? void 0 : event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text");
    var isSelectedInLinkMarkup = function() {
      if (!cursor.selection) {
        return false;
      }
      var linkMarkupRangeList = Array.from(cursor.value.matchAll(LINK_MARKUP_RE)).map(function(match) {
        return [match.index, match.index + match[0].length];
      });
      return linkMarkupRangeList.some(function(_a2) {
        var start = _a2[0], end = _a2[1];
        return isBtwOrEq(cursor.selection.selectionStart, start, end) || isBtwOrEq(cursor.selection.selectionEnd, start, end);
      });
    }();
    if (
      // make sure there is something on the clipboard
      !clipboard || // make sure there is url on the clipboard
      !isURL(clipboard) || // make sure there something is selected
      !cursor.selection || // make selected text is not a URL
      isURL(cursor.selection.text) || // make sure that selected is not inside link/image markup
      isSelectedInLinkMarkup
    ) {
      return;
    }
    event === null || event === void 0 ? void 0 : event.preventDefault();
    if (isImageURL(clipboard)) {
      cursor.insert("![".concat(cursor.selection.text, "](").concat(clipboard, ") ").concat(Cursor.MARKER));
    } else {
      cursor.insert("[".concat(cursor.selection.text, "](").concat(clipboard, ") ").concat(Cursor.MARKER));
    }
  };
  textarea.addEventListener("paste", pasteListener);
  return function() {
    return textarea.removeEventListener("paste", pasteListener);
  };
};
var indentExtension = function(textarea) {
  var mousetrap = (0, import_mousetrap.default)(textarea);
  var cursor = new Cursor(textarea);
  mousetrap.bind("tab", function(event) {
    event === null || event === void 0 ? void 0 : event.preventDefault();
    var indent = " ".repeat(4);
    if (!cursor.selection) {
      cursor.insert("".concat(indent).concat(Cursor.MARKER));
    } else {
      cursor.replaceCurrentLines(function(line) {
        return indent + line.text;
      }, { selectReplaced: true });
    }
  });
  mousetrap.bind("shift+tab", function(event) {
    event === null || event === void 0 ? void 0 : event.preventDefault();
    cursor.replaceCurrentLines(function(line) {
      return line.text.replace(/\s{0,4}/, "");
    }, {
      // select lines if something was selected
      selectReplaced: Boolean(cursor.selection)
    });
  });
  return function() {
    return mousetrap.reset();
  };
};
var prefixWrappingExtension = function(textarea, options) {
  var cursor = new Cursor(textarea);
  var ensureRegExp = function(value) {
    return value instanceof RegExp ? value : new RegExp(escapeRegExp(value));
  };
  var getLineRegExp = function(prefixRe) {
    return new RegExp("^\\s*(".concat(prefixRe.source, ").*$"));
  };
  var toConfig = function(value) {
    return typeof value === "string" ? { prefix: value, prefixPattern: ensureRegExp(value) } : value;
  };
  var getIndent = function(text) {
    var _a, _b;
    return " ".repeat((_b = (_a = text.match(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0);
  };
  var customConfigs = options.customPrefixWrapping.map(toConfig);
  var buildInConfigs = [
    {
      prefix: "".concat(options.preferredUnorderedListSyntax, " "),
      shouldBreakIfEmpty: true,
      shouldSaveIndent: true
    },
    {
      prefixPattern: /(\d+\.){1,2}\s+/,
      prefix: function(line) {
        var _a, _b;
        return getIncrementedOrderedListPrefix((_b = (_a = /^(\s*((\d+\.){1,2})\s+.*)$/.exec(line.text)) === null || _a === void 0 ? void 0 : _a[2]) !== null && _b !== void 0 ? _b : "") + " ";
      },
      shouldBreakIfEmpty: true,
      shouldSaveIndent: true
    }
  ];
  var configs = __spreadArray2(__spreadArray2([], customConfigs, true), buildInConfigs, true);
  var keydownListener = function(event) {
    if (event.code !== "Enter") {
      return;
    }
    var enteringLine = cursor.lineAt(cursor.position.line.lineNumber);
    var strictConfigs = configs.map(function(config) {
      var _a;
      var prefix2 = config.prefix instanceof Function ? config.prefix(enteringLine) : config.prefix;
      var pattern = ensureRegExp((_a = config.prefixPattern) !== null && _a !== void 0 ? _a : prefix2);
      var shouldBreak2 = config.shouldBreakIfEmpty === false ? false : !enteringLine.text.replace(pattern, "").trim();
      var shouldSaveIndent2 = config.shouldSaveIndent !== false;
      return { prefix: prefix2, pattern, shouldBreak: shouldBreak2, shouldSaveIndent: shouldSaveIndent2 };
    });
    var matched = strictConfigs.find(function(_a) {
      var pattern = _a.pattern;
      return getLineRegExp(pattern).test(enteringLine.text);
    });
    if (!matched) {
      return;
    }
    var prefix = matched.prefix, shouldBreak = matched.shouldBreak, shouldSaveIndent = matched.shouldSaveIndent;
    if (shouldBreak) {
      cursor.replaceLine(enteringLine.lineNumber, "");
      return;
    }
    event === null || event === void 0 ? void 0 : event.preventDefault();
    var indent = shouldSaveIndent ? getIndent(enteringLine.text) : "";
    cursor.insert("\n".concat(indent).concat(prefix).concat(Cursor.MARKER));
  };
  textarea.addEventListener("keydown", keydownListener);
  return function() {
    return textarea.removeEventListener("keydown", keydownListener);
  };
};
var properLineRemoveBehaviorExtension = function(textarea) {
  var cursor = new Cursor(textarea);
  var mousetrap = (0, import_mousetrap.default)(textarea);
  mousetrap.bind(metaCombination("backspace"), function(event) {
    if (cursor.position.line.text === "") {
      event.preventDefault();
      cursor.replaceLine(cursor.position.line.lineNumber, null);
    }
  });
  return function() {
    return mousetrap.reset();
  };
};
var orderedListAutoCorrectExtension = function(textarea) {
  var cursor = new Cursor(textarea);
  var INVALID_PATTERN = /^\s*(\d+(\.\d+)?\.?)\)\s*/;
  var handler = function(event) {
    var _a, _b;
    if (event.code !== "Enter") {
      return;
    }
    var lineText = cursor.position.line.text;
    var match = lineText.match(INVALID_PATTERN);
    if (!match) {
      return;
    }
    event === null || event === void 0 ? void 0 : event.preventDefault();
    var indent = " ".repeat((_b = (_a = lineText.match(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0);
    var orderPrefix = match[1];
    var newLineContent = "".concat(indent).concat(orderPrefix, ". ").concat(lineText.slice(match[0].length));
    cursor.replaceLine(cursor.position.line.lineNumber, newLineContent);
    textarea.dispatchEvent(new KeyboardEvent("keydown", event));
  };
  textarea.addEventListener("keydown", handler);
  return function() {
    return textarea.removeEventListener("keydown", handler);
  };
};

// node_modules/textarea-markdown-editor/dist/esm/types.js
var BUILT_IN_COMMANDS = [
  "bold",
  "italic",
  "strike-through",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "unordered-list",
  "ordered-list",
  "code-block",
  "code-inline",
  "code",
  "link",
  "image",
  "block-quotes"
];
var defaultTextareaMarkdownOptions = {
  preferredUnorderedListSyntax: "-",
  preferredBoldSyntax: "**",
  preferredItalicSyntax: "*",
  enableIndentExtension: true,
  enableLinkPasteExtension: true,
  enablePrefixWrappingExtension: true,
  enableProperLineRemoveBehaviorExtension: true,
  enableOrderedListAutoCorrectExtension: false,
  customPrefixWrapping: [],
  boldPlaceholder: "bold",
  italicPlaceholder: "italic",
  strikeThroughPlaceholder: "strike through",
  codeInlinePlaceholder: "code",
  codeBlockPlaceholder: "code block",
  orderedListPlaceholder: "ordered list",
  unorderedListPlaceholder: "unordered list",
  headlinePlaceholder: function(lvl) {
    return "headline ".concat(lvl);
  },
  blockQuotesPlaceholder: "quote",
  linkTextPlaceholder: "example",
  linkUrlPlaceholder: "url",
  imageTextPlaceholder: "example",
  imageUrlPlaceholder: "image.png"
};

// node_modules/textarea-markdown-editor/dist/esm/bootstrap.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var bootstrapTextareaMarkdown = function(textarea, config) {
  if (config === void 0) {
    config = {};
  }
  var cursor = new Cursor(textarea);
  var mousetrap = new import_mousetrap2.default(textarea);
  var commands = mergedCommandsList(config.commands);
  var options = __assign(__assign({}, defaultTextareaMarkdownOptions), config.options);
  var trigger = function(name) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var command = findLast(commands, function(c) {
      return c.name === name;
    });
    var keyEvent = isKeyboardArg(args[0]) ? args[0].keyEvent : void 0;
    var handlerArgs = isKeyboardArg(args[0]) ? [] : args;
    if (!command) {
      throw new TypeError('Command with name "'.concat(name, '" is not defined'));
    }
    if (command.enable === false) {
      return;
    }
    textarea.focus();
    command.handler.apply(command, __spreadArray3([{ textarea, keyEvent, options, cursor }], handlerArgs !== null && handlerArgs !== void 0 ? handlerArgs : [], false));
  };
  commands.forEach(function(command) {
    if (command.shortcut) {
      mousetrap.bind(command.shortcut, function(keyEvent) {
        if (command.shortcutPreventDefault) {
          keyEvent.preventDefault();
        }
        trigger(command.name, { __keyboard: true, keyEvent });
      });
    }
  });
  var extensions = [
    // fixUndoBehaviorExtension(textarea, options),
    options.enableIndentExtension && indentExtension(textarea, options),
    options.enableLinkPasteExtension && linkPasteExtension(textarea, options),
    options.enablePrefixWrappingExtension && prefixWrappingExtension(textarea, options),
    options.enableProperLineRemoveBehaviorExtension && properLineRemoveBehaviorExtension(textarea, options),
    options.enableOrderedListAutoCorrectExtension && orderedListAutoCorrectExtension(textarea, options)
  ];
  var dispose = function() {
    mousetrap.reset();
    extensions.forEach(function(cleanupExtension) {
      return cleanupExtension instanceof Function && cleanupExtension();
    });
  };
  return {
    trigger,
    dispose,
    cursor
  };
};
var isKeyboardArg = function(arg) {
  return arg !== null && typeof arg === "object" && arg.__keyboard === true;
};
var mergedCommandsList = function(customCommands) {
  if (customCommands === void 0) {
    customCommands = [];
  }
  var commands = __spreadArray3([], buildInCommands, true);
  customCommands === null || customCommands === void 0 ? void 0 : customCommands.forEach(function(command) {
    if (BUILT_IN_COMMANDS.includes(command.name)) {
      var commandIndex = buildInCommands.findIndex(function(x) {
        return x.name === command.name;
      });
      var overrides = {
        name: commands[commandIndex].name,
        handler: commands[commandIndex].handler,
        enable: command.enable,
        shortcut: command.shortcut
      };
      commands[commandIndex] = overrides;
    } else {
      if (!command.handler || !(command.handler instanceof Function)) {
        throw new TypeError("Custom command should have a handler function");
      }
      commands.push(command);
    }
  });
  return commands;
};
export {
  bootstrapTextareaMarkdown
};
//# sourceMappingURL=textarea-markdown-editor_dist_esm_bootstrap.js.map
