import { toString } from 'hast-util-to-string';
import { visit } from 'unist-util-visit';

const rehypeShikiFromHighlighter = function(highlighter, options) {
  const {
    addLanguageClass = false,
    parseMetaString,
    cache,
    ...rest
  } = options;
  const prefix = "language-";
  return function(tree) {
    visit(tree, "element", (node, index, parent) => {
      if (!parent || index == null || node.tagName !== "pre")
        return;
      const head = node.children[0];
      if (!head || head.type !== "element" || head.tagName !== "code" || !head.properties)
        return;
      const classes = head.properties.className;
      if (!Array.isArray(classes))
        return;
      const language = classes.find(
        (d) => typeof d === "string" && d.startsWith(prefix)
      );
      if (typeof language !== "string")
        return;
      const code = toString(head);
      const cachedValue = cache?.get(code);
      if (cachedValue) {
        parent.children.splice(index, 1, ...cachedValue);
        return;
      }
      const metaString = head.data?.meta ?? head.properties.metastring ?? "";
      const meta = parseMetaString?.(metaString, node, tree) || {};
      const codeOptions = {
        ...rest,
        lang: language.slice(prefix.length),
        meta: {
          ...rest.meta,
          ...meta,
          __raw: metaString
        }
      };
      if (addLanguageClass) {
        codeOptions.transformers || (codeOptions.transformers = []);
        codeOptions.transformers.push({
          name: "rehype-shiki:code-language-class",
          code(node2) {
            this.addClassToHast(node2, language);
            return node2;
          }
        });
      }
      try {
        const fragment = highlighter.codeToHast(code, codeOptions);
        cache?.set(code, fragment.children);
        parent.children.splice(index, 1, ...fragment.children);
      } catch (error) {
        if (options.onError)
          options.onError(error);
        else
          throw error;
      }
    });
  };
};

export { rehypeShikiFromHighlighter as default };
