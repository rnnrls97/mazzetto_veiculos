"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bootstrapTextareaMarkdown = void 0;
var mousetrap_1 = __importDefault(require("mousetrap"));
var commands_1 = require("./commands");
var Cursor_new_1 = require("./Cursor.new");
var extensions_1 = require("./extensions");
var types_1 = require("./types");
var utils_1 = require("./utils");
var bootstrapTextareaMarkdown = function (textarea, config) {
    if (config === void 0) { config = {}; }
    var cursor = new Cursor_new_1.Cursor(textarea);
    var mousetrap = new mousetrap_1.default(textarea);
    var commands = mergedCommandsList(config.commands);
    var options = __assign(__assign({}, types_1.defaultTextareaMarkdownOptions), config.options);
    var trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var command = (0, utils_1.findLast)(commands, function (c) { return c.name === name; });
        var keyEvent = isKeyboardArg(args[0]) ? args[0].keyEvent : undefined;
        var handlerArgs = isKeyboardArg(args[0]) ? [] : args;
        if (!command) {
            throw new TypeError("Command with name \"".concat(name, "\" is not defined"));
        }
        // ! disabled only if `false`
        if (command.enable === false) {
            return;
        }
        textarea.focus();
        command.handler.apply(command, __spreadArray([{ textarea: textarea, keyEvent: keyEvent, options: options, cursor: cursor }], (handlerArgs !== null && handlerArgs !== void 0 ? handlerArgs : []), false));
    };
    // subscribe on shortcuts
    commands.forEach(function (command) {
        if (command.shortcut) {
            mousetrap.bind(command.shortcut, function (keyEvent) {
                if (command.shortcutPreventDefault) {
                    keyEvent.preventDefault();
                }
                trigger(command.name, { __keyboard: true, keyEvent: keyEvent });
            });
        }
    });
    // bootstrap extensions if enabled, extension can optionally returns a cleanup function, which will be called inside dispose
    var extensions = [
        (0, extensions_1.fixUndoBehaviorExtension)(textarea, options),
        options.enableIndentExtension && (0, extensions_1.indentExtension)(textarea, options),
        options.enableLinkPasteExtension && (0, extensions_1.linkPasteExtension)(textarea, options),
        options.enablePrefixWrappingExtension && (0, extensions_1.prefixWrappingExtension)(textarea, options),
        options.enableProperLineRemoveBehaviorExtension && (0, extensions_1.properLineRemoveBehaviorExtension)(textarea, options),
        options.enableOrderedListAutoCorrectExtension && (0, extensions_1.orderedListAutoCorrectExtension)(textarea, options),
    ];
    // unsubscribe from all listeners
    var dispose = function () {
        mousetrap.reset();
        extensions.forEach(function (cleanupExtension) { return cleanupExtension instanceof Function && cleanupExtension(); });
    };
    return {
        trigger: trigger,
        dispose: dispose,
        cursor: cursor,
    };
};
exports.bootstrapTextareaMarkdown = bootstrapTextareaMarkdown;
var isKeyboardArg = function (arg) {
    return arg !== null && typeof arg === 'object' && arg.__keyboard === true;
};
var mergedCommandsList = function (customCommands) {
    if (customCommands === void 0) { customCommands = []; }
    var commands = __spreadArray([], commands_1.buildInCommands, true);
    customCommands === null || customCommands === void 0 ? void 0 : customCommands.forEach(function (command) {
        if (types_1.BUILT_IN_COMMANDS.includes(command.name)) {
            var commandIndex = commands_1.buildInCommands.findIndex(function (x) { return x.name === command.name; });
            var overrides = {
                name: commands[commandIndex].name,
                handler: commands[commandIndex].handler,
                enable: command.enable,
                shortcut: command.shortcut,
            };
            commands[commandIndex] = overrides;
        }
        else {
            if (!command.handler || !(command.handler instanceof Function)) {
                throw new TypeError('Custom command should have a handler function');
            }
            commands.push(command);
        }
    });
    return commands;
};
