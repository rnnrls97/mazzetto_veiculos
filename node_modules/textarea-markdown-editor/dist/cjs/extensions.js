"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixUndoBehaviorExtension = exports.orderedListAutoCorrectExtension = exports.properLineRemoveBehaviorExtension = exports.prefixWrappingExtension = exports.indentExtension = exports.linkPasteExtension = void 0;
var utils_1 = require("./utils");
var Cursor_new_1 = require("./Cursor.new");
var mousetrap_1 = __importDefault(require("mousetrap"));
/**
 * Handle the paste event, if the pasted text is a URL and something is selected, it will be converted to link/image markup.
 */
var linkPasteExtension = function (textarea) {
    var cursor = new Cursor_new_1.Cursor(textarea);
    var pasteListener = function (event) {
        var _a;
        var LINK_MARKUP_RE = /\[[^\]]*\]\([^)]*\)/g;
        var clipboard = (_a = event === null || event === void 0 ? void 0 : event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text');
        // checks if selected is already inside link or image markup
        var isSelectedInLinkMarkup = (function () {
            if (!cursor.selection) {
                return false;
            }
            // get all links markup ranges
            var linkMarkupRangeList = Array.from(cursor.value.matchAll(LINK_MARKUP_RE)).map(function (match) { return [match.index, match.index + match[0].length]; });
            // check if selected text is inside any of those ranges
            return linkMarkupRangeList.some(function (_a) {
                var start = _a[0], end = _a[1];
                return (0, utils_1.isBtwOrEq)(cursor.selection.selectionStart, start, end) ||
                    (0, utils_1.isBtwOrEq)(cursor.selection.selectionEnd, start, end);
            });
        })();
        if (
        // make sure there is something on the clipboard
        !clipboard ||
            // make sure there is url on the clipboard
            !(0, utils_1.isURL)(clipboard) ||
            // make sure there something is selected
            !cursor.selection ||
            // make selected text is not a URL
            (0, utils_1.isURL)(cursor.selection.text) ||
            // make sure that selected is not inside link/image markup
            isSelectedInLinkMarkup) {
            return;
        }
        // prevent default paste behavior
        event === null || event === void 0 ? void 0 : event.preventDefault();
        // workaround to avoid code copypaste
        if ((0, utils_1.isImageURL)(clipboard)) {
            cursor.insert("![".concat(cursor.selection.text, "](").concat(clipboard, ") ").concat(Cursor_new_1.Cursor.MARKER));
        }
        else {
            cursor.insert("[".concat(cursor.selection.text, "](").concat(clipboard, ") ").concat(Cursor_new_1.Cursor.MARKER));
        }
    };
    textarea.addEventListener('paste', pasteListener);
    return function () { return textarea.removeEventListener('paste', pasteListener); };
};
exports.linkPasteExtension = linkPasteExtension;
/**
 * Handle `tab`/`shift+tab` combination. Will insert or remove an intend depends on selection
 */
var indentExtension = function (textarea) {
    var mousetrap = (0, mousetrap_1.default)(textarea);
    var cursor = new Cursor_new_1.Cursor(textarea);
    mousetrap.bind('tab', function (event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        var indent = ' '.repeat(4);
        if (!cursor.selection) {
            // If nothing is selected simply add Indent at the current position
            cursor.insert("".concat(indent).concat(Cursor_new_1.Cursor.MARKER));
        }
        else {
            // If user is select line or lines - add Indent for each of this selected line, and keep selection
            cursor.replaceCurrentLines(function (line) { return indent + line.text; }, { selectReplaced: true });
        }
    });
    mousetrap.bind('shift+tab', function (event) {
        event === null || event === void 0 ? void 0 : event.preventDefault();
        cursor.replaceCurrentLines(function (line) { return line.text.replace(/\s{0,4}/, ''); }, {
            // select lines if something was selected
            selectReplaced: Boolean(cursor.selection),
        });
    });
    return function () { return mousetrap.reset(); };
};
exports.indentExtension = indentExtension;
/**
 * Handle next-line event. Will wrap current list sequence if needed
 */
var prefixWrappingExtension = function (textarea, options) {
    var cursor = new Cursor_new_1.Cursor(textarea);
    var ensureRegExp = function (value) {
        return value instanceof RegExp ? value : new RegExp((0, utils_1.escapeRegExp)(value));
    };
    var getLineRegExp = function (prefixRe) { return new RegExp("^\\s*(".concat(prefixRe.source, ").*$")); };
    var toConfig = function (value) {
        return typeof value === 'string' ? { prefix: value, prefixPattern: ensureRegExp(value) } : value;
    };
    var getIndent = function (text) { var _a, _b; return ' '.repeat((_b = (_a = text.match(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0); };
    var customConfigs = options.customPrefixWrapping.map(toConfig);
    var buildInConfigs = [
        {
            prefix: "".concat(options.preferredUnorderedListSyntax, " "),
            shouldBreakIfEmpty: true,
            shouldSaveIndent: true,
        },
        {
            prefixPattern: /(\d+\.){1,2}\s+/,
            prefix: function (line) { var _a, _b; return (0, utils_1.getIncrementedOrderedListPrefix)((_b = (_a = /^(\s*((\d+\.){1,2})\s+.*)$/.exec(line.text)) === null || _a === void 0 ? void 0 : _a[2]) !== null && _b !== void 0 ? _b : '') + ' '; },
            shouldBreakIfEmpty: true,
            shouldSaveIndent: true,
        },
    ];
    var configs = __spreadArray(__spreadArray([], customConfigs, true), buildInConfigs, true);
    var keydownListener = function (event) {
        if (event.code !== 'Enter') {
            return;
        }
        // this code bellow should be executed before default behavior.
        // entering line â€“ is line on which the Enter was pressed
        var enteringLine = cursor.lineAt(cursor.position.line.lineNumber);
        var strictConfigs = configs.map(function (config) {
            var _a;
            var prefix = config.prefix instanceof Function ? config.prefix(enteringLine) : config.prefix;
            var pattern = ensureRegExp((_a = config.prefixPattern) !== null && _a !== void 0 ? _a : prefix);
            var shouldBreak = config.shouldBreakIfEmpty === false ? false : !enteringLine.text.replace(pattern, '').trim();
            var shouldSaveIndent = config.shouldSaveIndent !== false;
            return { prefix: prefix, pattern: pattern, shouldBreak: shouldBreak, shouldSaveIndent: shouldSaveIndent };
        });
        var matched = strictConfigs.find(function (_a) {
            var pattern = _a.pattern;
            return getLineRegExp(pattern).test(enteringLine.text);
        });
        if (!matched) {
            // no matches
            return;
        }
        var prefix = matched.prefix, shouldBreak = matched.shouldBreak, shouldSaveIndent = matched.shouldSaveIndent;
        if (shouldBreak) {
            // for a list line without content remove prefix of this line before default behavior
            cursor.replaceLine(enteringLine.lineNumber, '');
            return;
        }
        event === null || event === void 0 ? void 0 : event.preventDefault();
        // if shouldSaveIndent need to wrap prefix within intent of entering line
        var indent = shouldSaveIndent ? getIndent(enteringLine.text) : '';
        cursor.insert("\n".concat(indent).concat(prefix).concat(Cursor_new_1.Cursor.MARKER));
    };
    textarea.addEventListener('keydown', keydownListener);
    return function () { return textarea.removeEventListener('keydown', keydownListener); };
};
exports.prefixWrappingExtension = prefixWrappingExtension;
var properLineRemoveBehaviorExtension = function (textarea) {
    var cursor = new Cursor_new_1.Cursor(textarea);
    var mousetrap = (0, mousetrap_1.default)(textarea);
    mousetrap.bind((0, utils_1.metaCombination)('backspace'), function (event) {
        if (cursor.position.line.text === '') {
            event.preventDefault();
            cursor.replaceLine(cursor.position.line.lineNumber, null);
        }
    });
    return function () { return mousetrap.reset(); };
};
exports.properLineRemoveBehaviorExtension = properLineRemoveBehaviorExtension;
var orderedListAutoCorrectExtension = function (textarea) {
    var cursor = new Cursor_new_1.Cursor(textarea);
    // eg: 1)content | 1) content | 1.1)content
    var INVALID_PATTERN = /^\s*(\d+(\.\d+)?\.?)\)\s*/;
    var handler = function (event) {
        var _a, _b;
        if (event.code !== 'Enter') {
            return;
        }
        var lineText = cursor.position.line.text;
        var match = lineText.match(INVALID_PATTERN);
        if (!match) {
            return;
        }
        event === null || event === void 0 ? void 0 : event.preventDefault();
        var indent = ' '.repeat((_b = (_a = lineText.match(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0);
        var orderPrefix = match[1];
        var newLineContent = "".concat(indent).concat(orderPrefix, ". ").concat(lineText.slice(match[0].length));
        cursor.replaceLine(cursor.position.line.lineNumber, newLineContent);
        textarea.dispatchEvent(new KeyboardEvent('keydown', event));
    };
    textarea.addEventListener('keydown', handler);
    return function () { return textarea.removeEventListener('keydown', handler); };
};
exports.orderedListAutoCorrectExtension = orderedListAutoCorrectExtension;
var toSnapshot = function (textarea) { return ({
    value: textarea.value,
    selectionStart: textarea.selectionStart,
    selectionEnd: textarea.selectionEnd,
}); };
var fixUndoBehaviorExtension = function (textarea) {
    var stack = new utils_1.HistoryStack(200);
    stack.push(toSnapshot(textarea));
    var cursor = new Cursor_new_1.Cursor(textarea);
    var mousetrap = (0, mousetrap_1.default)(textarea);
    var skipEvent = false;
    textarea.addEventListener('input', function () {
        var _a;
        if (skipEvent) {
            skipEvent = false;
            return;
        }
        if (textarea.value === ((_a = stack.peek(1)) === null || _a === void 0 ? void 0 : _a.value)) {
            return;
        }
        stack.push(toSnapshot(textarea));
    });
    mousetrap.bind((0, utils_1.metaCombination)('z'), function (event) {
        event.preventDefault();
        var previous = stack.peek(2);
        if (!previous) {
            return;
        }
        skipEvent = true;
        stack.pop(); // remove current snapshot
        cursor.setValue(previous.value);
        textarea.selectionStart = previous.selectionStart;
        textarea.selectionEnd = previous.selectionEnd;
    });
};
exports.fixUndoBehaviorExtension = fixUndoBehaviorExtension;
