var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import Mousetrap from 'mousetrap';
import { buildInCommands } from './commands';
import { Cursor } from './Cursor.new';
import { properLineRemoveBehaviorExtension, indentExtension, linkPasteExtension, prefixWrappingExtension, orderedListAutoCorrectExtension, } from './extensions';
import { defaultTextareaMarkdownOptions, BUILT_IN_COMMANDS, } from './types';
import { findLast } from './utils';
export var bootstrapTextareaMarkdown = function (textarea, config) {
    if (config === void 0) { config = {}; }
    var cursor = new Cursor(textarea);
    var mousetrap = new Mousetrap(textarea);
    var commands = mergedCommandsList(config.commands);
    var options = __assign(__assign({}, defaultTextareaMarkdownOptions), config.options);
    var trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var command = findLast(commands, function (c) { return c.name === name; });
        var keyEvent = isKeyboardArg(args[0]) ? args[0].keyEvent : undefined;
        var handlerArgs = isKeyboardArg(args[0]) ? [] : args;
        if (!command) {
            throw new TypeError("Command with name \"".concat(name, "\" is not defined"));
        }
        // ! disabled only if `false`
        if (command.enable === false) {
            return;
        }
        textarea.focus();
        command.handler.apply(command, __spreadArray([{ textarea: textarea, keyEvent: keyEvent, options: options, cursor: cursor }], (handlerArgs !== null && handlerArgs !== void 0 ? handlerArgs : []), false));
    };
    // subscribe on shortcuts
    commands.forEach(function (command) {
        if (command.shortcut) {
            mousetrap.bind(command.shortcut, function (keyEvent) {
                if (command.shortcutPreventDefault) {
                    keyEvent.preventDefault();
                }
                trigger(command.name, { __keyboard: true, keyEvent: keyEvent });
            });
        }
    });
    // bootstrap extensions if enabled, extension can optionally returns a cleanup function, which will be called inside dispose
    var extensions = [
        // fixUndoBehaviorExtension(textarea, options),
        options.enableIndentExtension && indentExtension(textarea, options),
        options.enableLinkPasteExtension && linkPasteExtension(textarea, options),
        options.enablePrefixWrappingExtension && prefixWrappingExtension(textarea, options),
        options.enableProperLineRemoveBehaviorExtension && properLineRemoveBehaviorExtension(textarea, options),
        options.enableOrderedListAutoCorrectExtension && orderedListAutoCorrectExtension(textarea, options),
    ];
    // unsubscribe from all listeners
    var dispose = function () {
        mousetrap.reset();
        extensions.forEach(function (cleanupExtension) { return cleanupExtension instanceof Function && cleanupExtension(); });
    };
    return {
        trigger: trigger,
        dispose: dispose,
        cursor: cursor,
    };
};
var isKeyboardArg = function (arg) {
    return arg !== null && typeof arg === 'object' && arg.__keyboard === true;
};
var mergedCommandsList = function (customCommands) {
    if (customCommands === void 0) { customCommands = []; }
    var commands = __spreadArray([], buildInCommands, true);
    customCommands === null || customCommands === void 0 ? void 0 : customCommands.forEach(function (command) {
        if (BUILT_IN_COMMANDS.includes(command.name)) {
            var commandIndex = buildInCommands.findIndex(function (x) { return x.name === command.name; });
            var overrides = {
                name: commands[commandIndex].name,
                handler: commands[commandIndex].handler,
                enable: command.enable,
                shortcut: command.shortcut,
            };
            commands[commandIndex] = overrides;
        }
        else {
            if (!command.handler || !(command.handler instanceof Function)) {
                throw new TypeError('Custom command should have a handler function');
            }
            commands.push(command);
        }
    });
    return commands;
};
