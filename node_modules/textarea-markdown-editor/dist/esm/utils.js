export var metaCombination = function () {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
    }
    return ["command+".concat(keys.join('+')), "ctrl+".concat(keys.join('+'))];
};
export var clamp = function (val, min, max) { return Math.min(Math.max(min, val), max); };
export var findLast = function (array, predicate) {
    var curIndex = array.length;
    while (curIndex--) {
        if (predicate(array[curIndex], curIndex, array))
            return array[curIndex];
    }
    return undefined;
};
export var trimChars = function (text, chars) {
    return text.replace(new RegExp('^[' + escapeRegExp(chars) + ']+|[' + chars + ']+$', 'g'), '');
};
export var isBtwOrEq = function (value, a, b) {
    return value >= Math.min(a, b) && value <= Math.max(a, b);
};
var browserSupportsTextareaTextNodes;
function canManipulateViaTextNodes(input) {
    if (input.nodeName !== 'TEXTAREA') {
        return false;
    }
    if (typeof browserSupportsTextareaTextNodes === 'undefined') {
        var textarea = document.createElement('textarea');
        textarea.value = '1';
        browserSupportsTextareaTextNodes = Boolean(textarea.firstChild);
    }
    return browserSupportsTextareaTextNodes;
}
/**
 * @param {HTMLTextAreaElement|HTMLInputElement} input
 * @param {string} value
 * @returns {void}
 */
export function fireInput(input, value) {
    // clear value before insertion
    // Most of the used APIs only work with the field selected
    input.focus();
    // since we replace all content
    input.select();
    // Webkit + Edge
    var isSuccess = document.execCommand && document.execCommand('insertText', false, value);
    input.selectionStart = input.value.length;
    if (!isSuccess) {
        var start = input.selectionStart;
        var end = input.selectionEnd;
        // Firefox (non-standard method)
        if (typeof input.setRangeText === 'function') {
            input.setRangeText(value);
        }
        else {
            //
            // To make a change we just need a Range, not a Selection
            var range = document.createRange();
            var textNode = document.createTextNode(value);
            if (canManipulateViaTextNodes(input)) {
                var node = input.firstChild;
                // If textarea is empty, just insert the text
                if (!node) {
                    input.appendChild(textNode);
                }
                else {
                    // Otherwise we need to find a nodes for start and end
                    var offset = 0;
                    var startNode = null;
                    var endNode = null;
                    while (node && (startNode === null || endNode === null)) {
                        var nodeLength = node.nodeValue.length;
                        // if start of the selection falls into current node
                        if (start >= offset && start <= offset + nodeLength) {
                            range.setStart((startNode = node), start - offset);
                        }
                        // if end of the selection falls into current node
                        if (end >= offset && end <= offset + nodeLength) {
                            range.setEnd((endNode = node), end - offset);
                        }
                        offset += nodeLength;
                        node = node.nextSibling;
                    }
                    // If there is some text selected, remove it as we should replace it
                    if (start !== end) {
                        range.deleteContents();
                    }
                }
            }
            // If the node is a textarea and the range doesn't span outside the element
            //
            // Get the commonAncestorContainer of the selected range and test its type
            // If the node is of type `#text` it means that we're still working with text nodes within our textarea element
            // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.
            if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {
                // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary
                range.insertNode(textNode);
            }
            else {
                // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value
                input.value = value;
            }
        }
        // Notify any possible listeners of the change
        var e = document.createEvent('UIEvent');
        e.initEvent('input', true, false);
        input.dispatchEvent(e);
    }
}
/**
 * 1. -> 2.
 * 1.1. -> 1.2.
 */
export var getIncrementedOrderedListPrefix = function (prefix) {
    var parts = trimChars(prefix.trim(), '.').split('.');
    var currentCount = parseInt(parts[parts.length - 1]);
    if (parts.length === 1) {
        return "".concat(currentCount + 1, ".");
    }
    return "".concat(parts.slice(0, -1).join('.'), ".").concat(currentCount + 1, ".");
};
export var isRefObject = function (ref) {
    return ref !== null && typeof ref === 'object';
};
/** Will try to find textarea or throws an Error  */
export var findTextArea = function (element) {
    var CHILDREN_ERROR_MSG = 'TextareaMarkdown wrapper: child element must be instance of HTMLTextAreaElement or container with an textarea element';
    if (!element) {
        throw new TypeError(CHILDREN_ERROR_MSG);
    }
    if (element instanceof HTMLTextAreaElement) {
        return element;
    }
    var queried = element.querySelector('textarea');
    if (queried instanceof HTMLTextAreaElement) {
        return queried;
    }
    throw new TypeError(CHILDREN_ERROR_MSG);
};
export function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
export var isURL = function (value) {
    try {
        return typeof value === 'string' && Boolean(new URL(value));
    }
    catch (error) {
        return false;
    }
};
export var isImageURL = function (value) {
    return isURL(value) && value.match(/\.(jpeg|jpg|gif|png)$/) !== null;
};
var HistoryStack = /** @class */ (function () {
    function HistoryStack(limit) {
        this.limit = limit;
        this.items = [];
    }
    HistoryStack.prototype.push = function (item) {
        this.items.push(item);
        if (this.items.length >= this.limit) {
            this.items.splice(0, 1);
        }
    };
    HistoryStack.prototype.peek = function (n) {
        return this.items[this.items.length - n];
    };
    HistoryStack.prototype.pop = function () {
        return this.items.pop();
    };
    return HistoryStack;
}());
export { HistoryStack };
