import { clamp, escapeRegExp } from './utils';
import { Cursor } from './Cursor.new';
export var boldCommandHandler = function (_a) {
    var cursor = _a.cursor, _b = _a.options, preferredBoldSyntax = _b.preferredBoldSyntax, boldPlaceholder = _b.boldPlaceholder;
    cursor.wrap(preferredBoldSyntax, { placeholder: boldPlaceholder });
};
export var italicCommandHandler = function (_a) {
    var cursor = _a.cursor, _b = _a.options, preferredItalicSyntax = _b.preferredItalicSyntax, italicPlaceholder = _b.italicPlaceholder;
    cursor.wrap(preferredItalicSyntax, { placeholder: italicPlaceholder });
};
export var linkCommandHandler = function (_a) {
    var _b;
    var options = _a.options, cursor = _a.cursor;
    var linkTextPlaceholder = options.linkTextPlaceholder, linkUrlPlaceholder = options.linkUrlPlaceholder;
    var linkText = ((_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.text) || linkTextPlaceholder;
    var linkUrl = linkUrlPlaceholder;
    cursor.insert("[".concat(linkText, "](").concat(Cursor.MARKER).concat(linkUrl).concat(Cursor.MARKER, ")"));
};
export var imageCommandHandler = function (_a) {
    var _b;
    var options = _a.options, cursor = _a.cursor;
    var imageTextPlaceholder = options.imageTextPlaceholder, imageUrlPlaceholder = options.imageUrlPlaceholder;
    var imageText = ((_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.text) || imageTextPlaceholder;
    var imageUrl = imageUrlPlaceholder;
    cursor.insert("![".concat(imageText, "](").concat(Cursor.MARKER).concat(imageUrl).concat(Cursor.MARKER, ")"));
};
export var orderedListCommandHandler = function (_a) {
    var _b, _c;
    var cursor = _a.cursor;
    var re = /(\d+\.){1,2}\s+/;
    var lines = (_c = (_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.lines) !== null && _c !== void 0 ? _c : [cursor.position.line];
    var needUndo = lines.every(function (line) { return re.test(line.text); });
    cursor.replaceCurrentLines(function (line, index) { return (needUndo ? line.text.replace(re, '') : "".concat(index + 1, ". ").concat(line.text)); }, {
        selectReplaced: Boolean(cursor.selection),
    });
};
export var unorderedListCommandHandler = function (_a) {
    var _b, _c;
    var cursor = _a.cursor, options = _a.options;
    var syntax = options.preferredUnorderedListSyntax;
    var re = new RegExp("^".concat(escapeRegExp(syntax), "\\s+"));
    var lines = (_c = (_b = cursor.selection) === null || _b === void 0 ? void 0 : _b.lines) !== null && _c !== void 0 ? _c : [cursor.position.line];
    var needUndo = lines.every(function (line) { return re.test(line.text); });
    cursor.replaceCurrentLines(function (line) { return (needUndo ? line.text.replace(re, '') : "".concat(syntax, " ").concat(line.text)); }, {
        selectReplaced: Boolean(cursor.selection),
    });
};
export var codeBlockCommandHandler = function (_a) {
    // TODO handle cases when selection start/end located not on start/end of a line
    // TODO: commend code doesn't works properly
    // const startLine = cursor.selection?.lines[0] ?? cursor.position.line;
    // const endLine = cursor.selection?.lines[0];
    // const needNextLineBefore = startLine.startsAt !== 0;
    // const needNextLineAfter = endLine && endLine.lineNumber !== startLine.lineNumber && endLine.endsAt < endLine.text.length;
    var cursor = _a.cursor, codeBlockPlaceholder = _a.options.codeBlockPlaceholder;
    cursor.wrap(['```\n', '\n```'], { placeholder: codeBlockPlaceholder });
};
export var codeInlineCommandHandler = function (_a) {
    var cursor = _a.cursor, codeInlinePlaceholder = _a.options.codeInlinePlaceholder;
    cursor.wrap('`', { placeholder: codeInlinePlaceholder });
};
export var codeCommandHandler = function (ctx) {
    var _a, _b;
    var selectedLines = (_b = (_a = ctx.cursor.selection) === null || _a === void 0 ? void 0 : _a.lines) !== null && _b !== void 0 ? _b : [];
    if (selectedLines.length > 1) {
        codeBlockCommandHandler(ctx);
    }
    else {
        codeInlineCommandHandler(ctx);
    }
};
export var blockQuotesCommandHandler = function (_a) {
    var cursor = _a.cursor, options = _a.options;
    cursor.replaceCurrentLines(function (line, index, lines) {
        return [
            index === 0 ? '> ' : '',
            index === 0 ? Cursor.MARKER : '',
            line.text.replace(/^>\s+/, '') || (index === 0 ? options.blockQuotesPlaceholder : ''),
            index === lines.length - 1 ? Cursor.MARKER : '', // selection closing for the last line
        ].join('');
    });
};
export var strikeThroughCommandHandler = function (_a) {
    var cursor = _a.cursor, strikeThroughPlaceholder = _a.options.strikeThroughPlaceholder;
    cursor.wrap('~~', { placeholder: strikeThroughPlaceholder });
};
export var createHeadlineCommandHandler = function (level) {
    return function (_a) {
        var cursor = _a.cursor, options = _a.options;
        var prefix = '#'.repeat(clamp(level, 1, 6)) + ' ';
        var headlinePlaceholder = options.headlinePlaceholder;
        var placeholder = headlinePlaceholder instanceof Function ? headlinePlaceholder(level) : headlinePlaceholder;
        var currentLine = cursor.position.line;
        var needUndo = currentLine.text.slice(0, level + 1) === prefix;
        var content = currentLine.text.replace(/^#{0,6}\s+/, '') || placeholder;
        cursor.replaceLine(currentLine.lineNumber, "".concat(needUndo ? '' : prefix).concat(Cursor.MARKER).concat(content).concat(Cursor.MARKER));
    };
};
