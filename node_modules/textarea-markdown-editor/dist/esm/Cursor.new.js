import { isBtwOrEq, fireInput } from './utils';
var MARKER = "\0";
/**
 * Util for manipulation with textarea content and text selection
 */
var Cursor = /** @class */ (function () {
    function Cursor(element) {
        this.element = element;
        this.MARKER = MARKER;
    }
    Object.defineProperty(Cursor.prototype, "value", {
        get: function () {
            return this.element.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Cursor.prototype, "lines", {
        /** @returns {Line[]} information about each line of text */
        get: function () {
            var currentLength = 0;
            return this.value.split('\n').reduce(function (lines, content, index, arr) {
                var lineNumber = index + 1;
                var isLastLine = index === arr.length - 1;
                var lineLength = content.length + Number(!isLastLine);
                var startsAt = currentLength;
                var endsAt = startsAt + lineLength - Number(!isLastLine);
                currentLength += lineLength;
                lines.push({
                    text: content,
                    lineNumber: lineNumber,
                    startsAt: startsAt,
                    endsAt: endsAt,
                });
                return lines;
            }, []);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Cursor.prototype, "selection", {
        /** @returns {Selection} information about current selection */
        get: function () {
            var selectionStart = this.element.selectionStart;
            var selectionEnd = this.element.selectionEnd;
            var selectionDirection = this.element.selectionDirection;
            var text = this.value.slice(selectionStart, selectionEnd);
            var lines = this.lines.filter(function (line) {
                // selection starts inside a line
                return isBtwOrEq(selectionStart, line.startsAt, line.endsAt) ||
                    // selection ends inside a line
                    isBtwOrEq(selectionEnd, line.startsAt, line.endsAt) ||
                    // line inside selection from left
                    isBtwOrEq(line.startsAt, selectionStart, selectionEnd) ||
                    // line inside selection from right
                    isBtwOrEq(line.endsAt, selectionStart, selectionEnd);
            });
            if (selectionStart === selectionEnd) {
                return null;
            }
            return { lines: lines, selectionStart: selectionStart, selectionEnd: selectionEnd, selectionDirection: selectionDirection, text: text };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Cursor.prototype, "position", {
        /** @returns {Position} information about current position */
        get: function () {
            var position = this.element.selectionStart;
            var line = this.lines.find(function (line) { return position >= line.startsAt && position <= line.endsAt; });
            return { cursorAt: position, line: line };
        },
        enumerable: false,
        configurable: true
    });
    Cursor.prototype.setValue = function (text) {
        var data = this.execRaw(text);
        // TODO check if there are other way to make it work
        if (process.env.NODE_ENV === 'test') {
            this.element.value = data.text;
        }
        else {
            fireInput(this.element, data.text);
        }
        if (data.selectionStart === null && data.selectionEnd === null) {
            return;
        }
        // if no end of selection or start == end
        if (data.selectionStart !== null && (data.selectionEnd === null || data.selectionStart === data.selectionEnd)) {
            this.element.selectionStart = data.selectionStart;
            this.element.selectionEnd = data.selectionStart;
        }
        else {
            this.element.setSelectionRange(data.selectionStart, data.selectionEnd);
        }
    };
    /**
     * @returns {Line} information about line
     * */
    Cursor.prototype.lineAt = function (lineNumber) {
        var _a;
        return (_a = this.lines[lineNumber - 1]) !== null && _a !== void 0 ? _a : null;
    };
    /**
     * Insert text at the cursor position.
     * if some content is selected will replace it
     */
    Cursor.prototype.insert = function (content) {
        if (!this.selection) {
            this.insertAtCursor(content);
            return;
        }
        var start = this.selection.selectionStart;
        var end = this.selection.selectionEnd;
        var newValue = this.value.slice(0, start) + this.normalizeSelection(content) + this.value.slice(end);
        this.setValue(newValue);
    };
    Cursor.prototype.insertAtCursor = function (content) {
        var cursorAt = this.position.cursorAt;
        var newValue = this.value.slice(0, cursorAt) +
            this.normalizeSelection(content) +
            this.value.slice(cursorAt, this.value.length);
        this.setValue(newValue);
    };
    /**
     * Replace all selected lines
     * if nothing is selected will replace the current line
     *
     * @param callback - The map function will be called once for each selected line and will replace the contents of the line with the result of the call
     * @note line is considered as selected even if it is partially selected
     */
    Cursor.prototype.replaceCurrentLines = function (callback, options) {
        var _this = this;
        var _a, _b;
        var _c = (options !== null && options !== void 0 ? options : {}).selectReplaced, selectReplaced = _c === void 0 ? false : _c;
        var selectedLines = (_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.lines) !== null && _b !== void 0 ? _b : [this.lineAt(this.position.line.lineNumber)];
        var content = selectedLines
            .map(function (line, index) { return callback.call(_this, line, index, selectedLines); })
            .filter(function (ctn) { return ctn !== null; }) // delete line if null
            .join('\n');
        var start = selectedLines[0].startsAt;
        var end = selectedLines[selectedLines.length - 1].endsAt;
        var newValue = this.value.slice(0, start) +
            this.normalizeSelection(content, selectReplaced ? 'SELECT_ALL' : 'TO_END') +
            this.value.slice(end);
        this.setValue(newValue);
    };
    /**
     * TODO
     * replace
     */
    Cursor.prototype.replaceLine = function (lineNumber, content) {
        var line = this.lineAt(lineNumber);
        if (!line) {
            console.error('Unknown line number: ' + lineNumber);
            return;
        }
        var start = line.startsAt;
        var end = line.endsAt;
        if (content === null) {
            // line should be removed
            this.setValue(this.value.slice(0, start - 1) + MARKER + this.value.slice(end));
            return;
        }
        var newValue = this.value.slice(0, start) + this.normalizeSelection(content) + this.value.slice(end);
        this.setValue(newValue);
    };
    /**
     * Wraps selection inside markup
     */
    Cursor.prototype.wrap = function (markup, options) {
        var _a, _b, _c, _d;
        var _e = options !== null && options !== void 0 ? options : {}, _f = _e.unwrap, unwrap = _f === void 0 ? true : _f, _g = _e.placeholder, placeholder = _g === void 0 ? '' : _g;
        var _h = Array.isArray(markup) ? markup : [markup, markup], prefix = _h[0], suffix = _h[1];
        var text = this.value;
        var start = (_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.selectionStart) !== null && _b !== void 0 ? _b : this.position.cursorAt;
        var end = (_d = (_c = this.selection) === null || _c === void 0 ? void 0 : _c.selectionEnd) !== null && _d !== void 0 ? _d : this.position.cursorAt;
        if (this.isSelectedWrappedWith(markup) && unwrap) {
            var content_1 = [
                text.slice(0, start - prefix.length),
                MARKER,
                text.slice(start, end),
                MARKER,
                text.slice(end + suffix.length),
            ].join('');
            this.setValue(content_1);
            return;
        }
        var content = [
            //
            text.slice(0, start),
            prefix,
            MARKER,
            text.slice(start, end) || placeholder,
            MARKER,
            suffix,
            text.slice(end),
        ].join('');
        this.setValue(content);
    };
    Cursor.prototype.isSelectedWrappedWith = function (markup) {
        var _a, _b, _c, _d;
        var _e = Array.isArray(markup) ? markup : [markup, markup], prefix = _e[0], suffix = _e[1];
        var start = (_b = (_a = this.selection) === null || _a === void 0 ? void 0 : _a.selectionStart) !== null && _b !== void 0 ? _b : this.position.cursorAt;
        var end = (_d = (_c = this.selection) === null || _c === void 0 ? void 0 : _c.selectionEnd) !== null && _d !== void 0 ? _d : this.position.cursorAt;
        if (start - prefix.length < 0 || end - 1 + suffix.length > this.value.length - 1) {
            return false;
        }
        var curPrefix = this.value.slice(start - prefix.length, start);
        var curSuffix = this.value.slice(end, end + suffix.length);
        return curPrefix === prefix && curSuffix === suffix;
    };
    Cursor.prototype.select = function (options) {
        var isRange = function (opt) {
            return (Object.prototype.hasOwnProperty.call(opt, 'start') && Object.prototype.hasOwnProperty.call(opt, 'end'));
        };
        if (isRange(options)) {
            this.element.setSelectionRange(options.start, options.end);
        }
        else {
            this.element.setSelectionRange(this.element.selectionStart + options.fromCurrentStart, this.element.selectionEnd + options.fromCurrentEnd);
        }
    };
    Cursor.prototype.normalizeSelection = function (text, defaultBehavior) {
        if (defaultBehavior === void 0) { defaultBehavior = 'TO_END'; }
        if (text.includes(MARKER)) {
            return text;
        }
        switch (defaultBehavior) {
            case 'TO_START':
                return "".concat(MARKER).concat(text);
            case 'TO_END':
                return "".concat(text).concat(MARKER);
            case 'SELECT_ALL':
                return "".concat(MARKER).concat(text).concat(MARKER);
        }
    };
    Cursor.prototype.execRaw = function (text) {
        var fIndex = text.indexOf(MARKER);
        var lIndex = text.lastIndexOf(MARKER);
        if (fIndex !== -1 && lIndex !== -1) {
            text = text.replace(new RegExp(MARKER, 'g'), '');
        }
        var selectionStart = null;
        var selectionEnd = null;
        // TODO: handle case with more than 2 markers
        if (fIndex !== -1) {
            selectionStart = fIndex;
            selectionEnd = lIndex === -1 || lIndex === fIndex ? null : lIndex - 1;
        }
        return { text: text, selectionStart: selectionStart, selectionEnd: selectionEnd };
    };
    Cursor.MARKER = MARKER;
    return Cursor;
}());
export { Cursor };
